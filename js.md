## 1.javascript是面向对象的，怎么体现javascript的继承关系

https://segmentfault.com/a/1190000008959943

#

## javascript的运行机制

- [ ] JavaScript的单线程机制
- [ ] 任务队列（同步任务和异步任务）
- [ ] 事件和回调函数
- [ ] 定时器
- [ ] Event Loop（事件循环）

**javascript的语言特性**：单线程。**同一时间只能做一件事**，当有多个任务的时候，只能按照顺序依次执行

设想JavaScript同时有两个线程，一个线程需要在某个DOM节点上添加内容，而另一个线程的操作是删除了这个节点，那么浏览器应该以谁为准呢？
所以为了避免复杂性，JavaScript从诞生起就是单线程。

为了提高CPU的利用率，HTML5提出Web Worker标准，允许javascript脚本创建多个线程，但是子线程完全受主线程控制，且不能操作DOM。所以这个标准并没有改变javascript单线程的本质


**任务队列**
排队的两种原因：
1.任务计算量过大，cpu处于忙碌状态
2.任务所需的东西没准备好所以无法继续执行，导致CPU闲置，等待输入输出设备（I/O设备）

由此JavaScript的设计者也意识到，这时完全可以先运行后面已经就绪的任务来提高运行效率，也就是把等待中的任务先挂起放到一边，等得到需要的东西再执行。就好比接电话时对方离开了一下，这时正好有另一个来电，于是你便把当前通话挂起，等那个通话结束后，再连回之前的通话。

所以也就出现了同步和异步的概念，任务也被分成了两种，一种是同步任务（Synchronous），另一种是异步任务

1.同步任务：需要执行的任务在主线程上排队，依次执行
2.异步任务：没有马上被执行单需要执行的任务，存在在“任务列表”，“任务列表”通知主线程什么时候哪个异步任务可以被执行

具体来说，异步执行如下：
1.所有同步任务都在主线程上，形成一个**执行栈**
2.主线程之外，还存在一个“任务列表”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。
也就是说每个异步任务准备好了就会立一个唯一的flag，这个flag用来标识对应的异步任务。
3.一旦“执行栈”中的所有同步任务执行完毕，就会来看“任务列表”的flag，来把对应的异步任务打包来执行。

**只要主线程空了，就会去读取“任务队列”。这个过程会被不断重复，这就是JavaScript的运行机制。**

**事件和回调函数**
事件：
“任务列表”是一个事件的列表，IO设备完成一项任务，就在“任务列表”中添加一个事件，表示相关的异步任务可以进入‘’执行栈”，接着按主线程读取“任务队列”，查看里面有哪些事件

“任务队列”中的时间，除了IO设备的时间以外，还包括一些用户产生的事件。只要指定过回调函数，这些事件发生时就会进入“任务队列”，等待主线程读取

回调函数：
所谓“回调函数”，就是那些会被主线程挂起来的代码。异步任务必须指定回到函数。单主线程开始执行异步任务时，就是执行对应的回调函数。
“任务列表”是一个先进先出的数据结构。主线程的读取过程基本上是自动的，只要执行栈已清空，“任务列表”上的第一位时间就主动进入线程，但是如果包含“计时器”，主线程要检查一下执行时间。某些事件只有到了规定时间，才会返回主线程主线程

#

## 事件绑定和普通事件的区别

**普通添加事件的方法：**

```
var btn = document.getElementById("hello");
btn.onclick = function(){
	alert(1);
}
btn.onclick = function(){
	alert(2);
}
```
执行上面的代码只会alert 2

**事件绑定方式添加事件：**

```
var btn = document.getElementById("hello");
btn.addEventListener("click",function(){
	alert(1);
},false);
btn.addEventListener("click",function(){
	alert(2);
},false);
```
执行上面的代码会先alert 1 再 alert 2

普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个。


#

## 媒体查询，或针对移动端的布局/css
媒体查询就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒体查询让css可以更加精确作用于不同的媒体类型和同一媒体的不同条件。

语法结构和用法：
@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}。


#

## this的绑定规则
**1.默认绑定**
独立函数调用时，this指向全局函数

```
function foo() {
 console.log(this.a);
}
var a = 2;
foo(); // 2
```
**2.隐式绑定**
当函数引用有上下文对象时，，隐式绑定规则会把函数调用中的this绑定到这个上下文对象

```
function foo() {
 console.log( this.a);
}
var obj = {
 a: 2,
 foo: foo
};
obj.foo(); // 2

```
对象属性引用链中只有最顶层或者说最后一层会影响调用位置
obj1.obj2.foo(); // foo 中的 this 与 obj2 绑定


隐式丢失
指的是函数中的this丢失绑定对象，引用默认绑定规则，从而将this绑定到全局对象或者undefined上

```
function foo() {
 console.log( this.a);
}
var obj = {
 a: 2,
 foo: foo
};
var bar = obj.foo; //函数别名
var a = "这是全局变量喔";
bar(); // "这是全局变量喔"
```

**3.显示绑定**
显示绑定的核心是javascript内置的call和apply方法，
```
function foo() {
 console.log( this.a);
}
var obj = {
 a: 2
};
foo.call(obj); // 2

```
如果call或者apply传入的第一个参数是原始值（字符串类型、布尔类型、数字类型），那么该原始值会被转换成它的对象形式（new String（）、new Boolean()、new Number（）），俗称：“装箱”


**4.new 绑定**
使用 new 来调用函数时，会自动执行下面的操作：

     1、创建一个全新的对象
     
     2、这个新对象会被执行 [[原型]] 连接
     
     3、这个新对象会绑定到函数调用的 this
     
     4、如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象


```
function foo() {
 this.a = a;
}
var bar = new foo(2);
console.log(bar.a); // 2
```


**优先级：**
1.函数是否在new中调用（new 绑定）？如果是的话this绑定的是新创建的对象
var bar = new foo（）

2.函数是否通过call、apply（显示绑定）？this绑定的是指定对象
var bar = foo.call(obj2);

3.函数是否在某个上下文对象中调用（隐式绑定），this绑定的是相应的上下文对象
var bar = obj1.foo();

3.如果都不是的话。使用默认绑定，如果在严格模式下，就绑定到undefined。否则绑定到全局对象
var bar = foo();


**绑定例外：**
如果把null或者undefined作为this的绑定对象传入call、apply、bind，那么这些值在调用时会被忽略，实际应用的是默认绑定规则
```
function foo() {
 console.log( this.a);
}
var a = 2；
var o = {a: 3, foo: foo};
var p = {a: 4};
o.foo(); // 3
(p.foo = o.foo)(); // 2
```

#

# 面向对象有三大特性：封装、继承、多态
[JS面向对象](https://www.cnblogs.com/pompey/p/6675559.html)






